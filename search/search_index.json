{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Django RESTQL is a python library which allows you to turn your API made with Django REST Framework(DRF) into a GraphQL like API. With Django RESTQL you will be able to Send a query to your API and get exactly what you need, nothing more and nothing less. Control the data you get, not the server. Get predictable results, since you control what you get from the server. Get nested resources in a single request. Avoid Over-fetching and Under-fetching of data. Write(create & update) nested data of any level in a single request. Isn't it cool?. Requirements \u00b6 Python >= 3.5 Django >= 1.11 Django REST Framework >= 3.5 Installing \u00b6 pip install django - restql Getting Started \u00b6 Using Django RESTQL to query data is very simple, you just have to inherit the DynamicFieldsMixin class when defining a serializer that's all. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = User fields = [ 'id' , 'username' , 'email' ] Django RESTQL handle all requests with a query parameter, this parameter is the one used to pass all fields to be included/excluded in a response. For example to select id and username fields from User model, send a request with a query parameter as shown below. GET /users/?query={id, username} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" }, ... ] Django RESTQL support querying both flat and nested resources, you can expand or query nested fields at any level as defined on a serializer. It also supports querying with all HTTP methods i.e (GET, POST, PUT & PATCH) You can do a lot with Django RESTQL apart from querying data, like Rename fields Restrict some fields on nested fields Define self referencing nested fields Optimize data fetching on nested fields Data filtering and pagination by using query arguments Data mutation(Create and update nested data of any level in a single request) Django RESTQL Play Ground \u00b6 Django RESTQL Play Ground is a graphical, interactive, in-browser tool which you can use to test Django RESTQL features like data querying, mutations etc to get the idea of how the library works before installing it. It's more like a live demo for Django RESTQL , it's available at https://django-restql-playground.yezyilomo.me","title":"Intro"},{"location":"#introduction","text":"Django RESTQL is a python library which allows you to turn your API made with Django REST Framework(DRF) into a GraphQL like API. With Django RESTQL you will be able to Send a query to your API and get exactly what you need, nothing more and nothing less. Control the data you get, not the server. Get predictable results, since you control what you get from the server. Get nested resources in a single request. Avoid Over-fetching and Under-fetching of data. Write(create & update) nested data of any level in a single request. Isn't it cool?.","title":"Introduction"},{"location":"#requirements","text":"Python >= 3.5 Django >= 1.11 Django REST Framework >= 3.5","title":"Requirements"},{"location":"#installing","text":"pip install django - restql","title":"Installing"},{"location":"#getting-started","text":"Using Django RESTQL to query data is very simple, you just have to inherit the DynamicFieldsMixin class when defining a serializer that's all. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = User fields = [ 'id' , 'username' , 'email' ] Django RESTQL handle all requests with a query parameter, this parameter is the one used to pass all fields to be included/excluded in a response. For example to select id and username fields from User model, send a request with a query parameter as shown below. GET /users/?query={id, username} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" }, ... ] Django RESTQL support querying both flat and nested resources, you can expand or query nested fields at any level as defined on a serializer. It also supports querying with all HTTP methods i.e (GET, POST, PUT & PATCH) You can do a lot with Django RESTQL apart from querying data, like Rename fields Restrict some fields on nested fields Define self referencing nested fields Optimize data fetching on nested fields Data filtering and pagination by using query arguments Data mutation(Create and update nested data of any level in a single request)","title":"Getting Started"},{"location":"#django-restql-play-ground","text":"Django RESTQL Play Ground is a graphical, interactive, in-browser tool which you can use to test Django RESTQL features like data querying, mutations etc to get the idea of how the library works before installing it. It's more like a live demo for Django RESTQL , it's available at https://django-restql-playground.yezyilomo.me","title":"Django RESTQL Play Ground"},{"location":"license/","text":"MIT License Copyright (c) 2019 Yezy Ilomo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"mutating_data/","text":"Mutating Data \u00b6 Django RESTQL got your back on creating and updating nested data too, it has two components for mutating nested data, NestedModelSerializer and NestedField . A serializer NestedModelSerializer has update and create logics for nested fields on the other hand NestedField is used to validate data before calling update or create method. Using NestedField and NestedModelSerializer \u00b6 Just like in querying data, mutating nested data with Django RESTQL is very simple, you just have to inherit NestedModelSerializer on a serializer with nested fields and use NestedField to define those nested fields which you want to be able to mutate. Below is an example which shows how to use NestedModelSerializer and NestedField . from rest_framework import serializers from django_restql.serializers import NestedModelSerializer from django_restql.fields import NestedField from app.models import Location , Amenity , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class AmenitySerializer ( serializers . ModelSerializer ): class Meta : model = Amenity fields = [ \"id\" , \"name\" ] # Inherit NestedModelSerializer to support create and update # on nested fields class PropertySerializer ( NestedModelSerializer ): # Define location as nested field location = NestedField ( LocationSerializer ) # Define amenities as nested field amenities = NestedField ( AmenitySerializer , many = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' , 'amenities' ] With serializers defined as shown above, you will be able to send data mutation request like POST /api/property/ With a request body like { \"price\" : 60000 , \"location\" : { \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : { \"add\" : [ 3 ], \"create\" : [ { \"name\" : \"Watererr\" }, { \"name\" : \"Electricity\" } ] } } And get a response as { \"id\" : 2 , \"price\" : 60000 , \"location\" : { \"id\" : 3 , \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Watererr\" }, { \"id\" : 2 , \"name\" : \"Electricity\" }, { \"id\" : 3 , \"name\" : \"Swimming Pool\" } ] } Just to clarify what happed here: location has been created and associated with the property created create operation has created amenities with values specified in a list and associate them with the property add operation has added amenity with id=3 to a list of amenities of the property. Note POST for many related fields supports two operations which are create and add . Below we have an example where we are trying to update the property we have created in the previous example. PUT/PATCH /api/property/2/ Request Body { \"price\" : 50000 , \"location\" : { \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : { \"add\" : [ 4 ], \"create\" : [{ \"name\" : \"Fance\" }], \"remove\" : [ 3 ], \"update\" : { 1 : { \"name\" : \"Water\" }} } } After sending the requst above we'll get a response which looks like { \"id\" : 2 , \"price\" : 50000 , \"location\" : { \"id\" : 3 , \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Water\" }, { \"id\" : 2 , \"name\" : \"Electricity\" }, { \"id\" : 4 , \"name\" : \"Bathtub\" }, { \"id\" : 5 , \"name\" : \"Fance\" } ] } From the request body add , create , remove and update are operations What you see in the response above are details of our property, what really happened after sending the update request is add operation added amenitiy with id=4 to a list of amenities of the property create operation created amenities with values specified in a list remove operation removed amenities with id=3 from a property update operation updated amenity with id=1 according to values specified. Note PUT/PATCH for many related fields supports four operations which are create , add , remove and update . Self referencing nested field \u00b6 Currently DRF doesn't allow declaring self referencing nested fields but you might have a self referencing nested field in your project since Django allows creating them. Django RESTQL comes with a nice way to deal with this scenario. Let's assume we have a student model as shows below # models.py class Student ( models . Model ): name = models . CharField ( max_length = 50 ) age = models . IntegerField () study_partners = models . ManyToManyField ( 'self' , related_name = 'study_partners' ) As you can see from the model above study_partners is a self referencing field. Below is the corresponding serializer for our model # serializers.py class StudentSerializer ( NestedModelSerializer ): # Define study_partners as self referencing nested field study_partners = NestedField ( 'self' , many = True , required = False , exclude = [ 'study_partners' ] ) class Meta : model = Student fields = [ 'id' , 'name' , 'age' , 'study_partners' ] You can see that we have passed self to NestedField just like in Student model, this means that study_partners field is a self referencing field. The other important thing here is exclude=['study_partners'] , this excludes the field study_partners on a nested field to avoid recursion error if the self reference is cyclic. NestedField kwargs \u00b6 NestedField accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a nested field as explained below. accept_pk kwarg \u00b6 accept_pk=True is used if you want to be able to update nested field by using pk/id of existing data(basically associate existing nested resource with the parent resource). This applies to foreign key relations only. The default value for accept_pk is False . Below is an example showing how to use accept_pk kwarg. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # pk based nested field location = NestedField ( LocationSerializer , accept_pk = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] Now sending mutation request as POST /api/property/ Request Body { \"price\" : 40000 , \"location\" : 2 } Note Here location resource with id=2 exists already, so what's done here is create a new property resource and associate it with this location whose id is 2. Response { \"id\" : 1 , \"price\" : 40000 , \"location\" : { \"id\" : 2 , \"city\" : \"Tokyo\" , \"country\" : \"China\" } } Using accept_pk doesn't limit you from sending data(instead of pk to nested resource), setting accept_pk=True means you can send both data and pks. For instance from the above example you could still do POST /api/property/ Request Body { \"price\" : 63000 , \"location\" : { \"city\" : \"Dodoma\" , \"country\" : \"Tanzania\" } } Response { \"id\" : 2 , \"price\" : 63000 , \"location\" : { \"id\" : 3 , \"city\" : \"Dodoma\" , \"country\" : \"Tanzania\" } } accept_pk_only kwarg \u00b6 accept_pk_only=True is used if you want to be able to update nested field by using pk/id only. This applies to foreign key relations only as well. The default value for accept_pk_only kwarg is False , if accept_pk_only=True is set you won't be able to send data to create a nested resource. Below is an example showing how to use accept_pk_only kwarg. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # pk based nested field location = NestedField ( LocationSerializer , accept_pk_only = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] Sending mutation request POST /api/property/ Request Body { \"price\" : 40000 , \"location\" : 2 // You can't send data in here, you can only send pk/id } Response { \"id\" : 1 , \"price\" : 40000 , \"location\" : { \"id\" : 2 , \"city\" : \"Tokyo\" , \"country\" : \"China\" } } Note By default accept_pk=False and accept_pk_only=False , so nested field(foreign key related) accepts data only by default, if accept_pk=True is set, it accepts data and pk/id, and if accept_pk_only=True is set it accepts pk/id only. You can't set both accept_pk=True and accept_pk_only=True . create_ops and update_ops kwargs. \u00b6 These two kwargs are used to restrict some operations when creating or updating nested data. Below is an example showing how to restrict some operations by using these two kwargs. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Amenity , Property class AmenitySerializer ( serializers . ModelSerializer ): class Meta : model = Amenity fields = [ \"id\" , \"name\" ] class PropertySerializer ( NestedModelSerializer ): amenities = NestedField ( AmenitySerializer , many = True , create_ops = [ \"add\" ], # Allow only add operation update_ops = [ \"add\" , \"remove\" ] # Allow only add and remove operations ) class Meta : model = Property fields = [ 'id' , 'price' , 'amenities' ] Sending create mutation request POST /api/property/ Request Body { \"price\" : 60000 , \"amenities\" : { \"add\" : [ 1 , 2 ] } } Note Since create_ops=[\"add\"] , you can't use create operation in here!. Response { \"id\" : 2 , \"price\" : 60000 , \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Watererr\" }, { \"id\" : 2 , \"name\" : \"Electricity\" } ] } Sending update mutation request PUT/PATCH /api/property/2/ Request Body { \"price\" : 50000 , \"amenities\" : { \"add\" : [ 3 ], \"remove\" : [ 2 ] } } Note Since update_ops=[\"add\", \"remove\"] , you can't use create or update operation in here!. Response { \"id\" : 2 , \"price\" : 50000 , \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Water\" }, { \"id\" : 3 , \"name\" : \"Bathtub\" } ] } allow_remove_all kwarg \u00b6 This kwarg is used to enable and disable removing all related objects on many related nested field at once by using __all__ directive. The default value of allow_remove_all is False , which means removing all related objects on many related nested fields is disabled by default so if you want to enable it you must set its value to True . For example class CourseSerializer ( NestedModelSerializer ): books = NestedField ( BookSerializer , many = True , allow_remove_all = True ) class Meta : model = Course fields = [ \"name\" , \"code\" , \"books\" ] With allow_remove_all=True as set above you will be able to send a request like PUT/PATCH /courses/3/ Request Body { \"books\" : { \"remove\" : \"__all__\" } } This will remove all books associated with a course being updated. Using DynamicFieldsMixin and NestedField together \u00b6 You can use DynamicFieldsMixin and NestedModelSerializer together if you want your serializer to be writable(on nested fields) and support querying data, this is very common. Below is an example which shows how you can use DynamicFieldsMixin and NestedField together. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] # Inherit both DynamicFieldsMixin and NestedModelSerializer class PropertySerializer ( DynamicFieldsMixin , NestedModelSerializer ): location = NestedField ( LocationSerializer ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] NestedField is nothing but a serializer wrapper, it returns an instance of a modified version of a serializer passed, so you can pass all the args and kwargs accepted by a serializer on it, it will simply pass them along to a serializer passed when instantiating an instance. So you can pass anything accepted by a serializer to a NestedField wrapper, and if a serializer passed inherits DynamicFieldsMixin just like LocationSerializer on the example above then you can pass any arg or kwarg accepted by DynamicFieldsMixin when defining location as a nested field, i.e location = NestedField ( LocationSerializer , fields = [ ... ]) location = NestedField ( LocationSerializer , exclude = [ ... ]) location = NestedField ( LocationSerializer , return_pk = True ) Note If you want to use required=False kwarg on NestedField you might want to include allow_null=True too if you want your nested field to be set to null if you haven't supplied it. For example from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # Passing both `required=False` and `allow_null=True` location = NestedField ( LocationSerializer , required = False , allow_null = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] The required=False kwarg allows you to create Property without including location field and the allow_null=True kwarg allows location field to be set to null if you haven't supplied it. For example Sending mutation request POST /api/property/ Request Body { \"price\" : 40000 // You can see that the location is not included here } Response { \"id\" : 2 , \"price\" : 50000 , \"location\" : null // This is the result of not including location } If you use required=False only without allow_null=True , The serializer will allow you to create Property without including location field but it will throw error because by default allow_null=False which means null / None (which is what's passed when you don't supply location value) is not considered a valid value. Working with data mutation without request \u00b6 Django RESTQL allows you to do data mutation without having request object, this is used if you don't want to get your mutation data input(serializer data) from a request, in fact NestedModelSerializer and NestedFied can work independently without using request. Below is an example showing how you can work with data mutation without request object. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , NestedModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , NestedModelSerializer ): books = NestedField ( BookSerializer , many = True , required = False ) class Meta : model = Course fields = [ 'id' , 'name' , 'code' , 'books' ] From serializers above you can create a course like data = { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : { \"add\" : [ 1 , 2 ], \"create\" : [ { 'title' : 'Basic Data Structures' , 'author' : 'J. Davis' }, { 'title' : 'Advanced Data Structures' , 'author' : 'S. Mobit' } ] } } serializer = CourseSerializer ( data = data ) serializer . is_valid () serializer . save () print ( serializer . data ) # This will print { \"id\" : 2 , \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { 'id' : 1 , 'title' : 'Programming Intro' , 'author' : 'K. Moses' }, { 'id' : 2 , 'title' : 'Understanding Computers' , 'author' : 'B. Gibson' }, { 'id' : 3 , 'title' : 'Basic Data Structures' , 'author' : 'J. Davis' }, { 'id' : 4 , 'title' : 'Advanced Data Structures' , 'author' : 'S. Mobit' } ] } To update a created course you can do it like data = { \"code\" : \"CS100\" , \"books\" : { \"remove\" : [ 2 , 3 ] } } course_obj = Course . objects . get ( pk = 2 ) serializer = CourseSerializer ( course_obj , data = data ) serializer . is_valid () serializer . save () print ( serializer . data ) # This will print { \"id\" : 2 , \"name\" : \"Computer Programming\" , \"code\" : \"CS100\" , \"books\" : [ { 'id' : 1 , 'title' : 'Programming Intro' , 'author' : 'K. Moses' }, { 'id' : 2 , 'title' : 'Understanding Computers' , 'author' : 'B. Gibson' } ] }","title":"Mutating Data"},{"location":"mutating_data/#mutating-data","text":"Django RESTQL got your back on creating and updating nested data too, it has two components for mutating nested data, NestedModelSerializer and NestedField . A serializer NestedModelSerializer has update and create logics for nested fields on the other hand NestedField is used to validate data before calling update or create method.","title":"Mutating Data"},{"location":"mutating_data/#using-nestedfield-and-nestedmodelserializer","text":"Just like in querying data, mutating nested data with Django RESTQL is very simple, you just have to inherit NestedModelSerializer on a serializer with nested fields and use NestedField to define those nested fields which you want to be able to mutate. Below is an example which shows how to use NestedModelSerializer and NestedField . from rest_framework import serializers from django_restql.serializers import NestedModelSerializer from django_restql.fields import NestedField from app.models import Location , Amenity , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class AmenitySerializer ( serializers . ModelSerializer ): class Meta : model = Amenity fields = [ \"id\" , \"name\" ] # Inherit NestedModelSerializer to support create and update # on nested fields class PropertySerializer ( NestedModelSerializer ): # Define location as nested field location = NestedField ( LocationSerializer ) # Define amenities as nested field amenities = NestedField ( AmenitySerializer , many = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' , 'amenities' ] With serializers defined as shown above, you will be able to send data mutation request like POST /api/property/ With a request body like { \"price\" : 60000 , \"location\" : { \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : { \"add\" : [ 3 ], \"create\" : [ { \"name\" : \"Watererr\" }, { \"name\" : \"Electricity\" } ] } } And get a response as { \"id\" : 2 , \"price\" : 60000 , \"location\" : { \"id\" : 3 , \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Watererr\" }, { \"id\" : 2 , \"name\" : \"Electricity\" }, { \"id\" : 3 , \"name\" : \"Swimming Pool\" } ] } Just to clarify what happed here: location has been created and associated with the property created create operation has created amenities with values specified in a list and associate them with the property add operation has added amenity with id=3 to a list of amenities of the property. Note POST for many related fields supports two operations which are create and add . Below we have an example where we are trying to update the property we have created in the previous example. PUT/PATCH /api/property/2/ Request Body { \"price\" : 50000 , \"location\" : { \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : { \"add\" : [ 4 ], \"create\" : [{ \"name\" : \"Fance\" }], \"remove\" : [ 3 ], \"update\" : { 1 : { \"name\" : \"Water\" }} } } After sending the requst above we'll get a response which looks like { \"id\" : 2 , \"price\" : 50000 , \"location\" : { \"id\" : 3 , \"city\" : \"Newyork\" , \"country\" : \"USA\" }, \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Water\" }, { \"id\" : 2 , \"name\" : \"Electricity\" }, { \"id\" : 4 , \"name\" : \"Bathtub\" }, { \"id\" : 5 , \"name\" : \"Fance\" } ] } From the request body add , create , remove and update are operations What you see in the response above are details of our property, what really happened after sending the update request is add operation added amenitiy with id=4 to a list of amenities of the property create operation created amenities with values specified in a list remove operation removed amenities with id=3 from a property update operation updated amenity with id=1 according to values specified. Note PUT/PATCH for many related fields supports four operations which are create , add , remove and update .","title":"Using NestedField and NestedModelSerializer"},{"location":"mutating_data/#self-referencing-nested-field","text":"Currently DRF doesn't allow declaring self referencing nested fields but you might have a self referencing nested field in your project since Django allows creating them. Django RESTQL comes with a nice way to deal with this scenario. Let's assume we have a student model as shows below # models.py class Student ( models . Model ): name = models . CharField ( max_length = 50 ) age = models . IntegerField () study_partners = models . ManyToManyField ( 'self' , related_name = 'study_partners' ) As you can see from the model above study_partners is a self referencing field. Below is the corresponding serializer for our model # serializers.py class StudentSerializer ( NestedModelSerializer ): # Define study_partners as self referencing nested field study_partners = NestedField ( 'self' , many = True , required = False , exclude = [ 'study_partners' ] ) class Meta : model = Student fields = [ 'id' , 'name' , 'age' , 'study_partners' ] You can see that we have passed self to NestedField just like in Student model, this means that study_partners field is a self referencing field. The other important thing here is exclude=['study_partners'] , this excludes the field study_partners on a nested field to avoid recursion error if the self reference is cyclic.","title":"Self referencing nested field"},{"location":"mutating_data/#nestedfield-kwargs","text":"NestedField accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a nested field as explained below.","title":"NestedField kwargs"},{"location":"mutating_data/#accept_pk-kwarg","text":"accept_pk=True is used if you want to be able to update nested field by using pk/id of existing data(basically associate existing nested resource with the parent resource). This applies to foreign key relations only. The default value for accept_pk is False . Below is an example showing how to use accept_pk kwarg. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # pk based nested field location = NestedField ( LocationSerializer , accept_pk = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] Now sending mutation request as POST /api/property/ Request Body { \"price\" : 40000 , \"location\" : 2 } Note Here location resource with id=2 exists already, so what's done here is create a new property resource and associate it with this location whose id is 2. Response { \"id\" : 1 , \"price\" : 40000 , \"location\" : { \"id\" : 2 , \"city\" : \"Tokyo\" , \"country\" : \"China\" } } Using accept_pk doesn't limit you from sending data(instead of pk to nested resource), setting accept_pk=True means you can send both data and pks. For instance from the above example you could still do POST /api/property/ Request Body { \"price\" : 63000 , \"location\" : { \"city\" : \"Dodoma\" , \"country\" : \"Tanzania\" } } Response { \"id\" : 2 , \"price\" : 63000 , \"location\" : { \"id\" : 3 , \"city\" : \"Dodoma\" , \"country\" : \"Tanzania\" } }","title":"accept_pk kwarg"},{"location":"mutating_data/#accept_pk_only-kwarg","text":"accept_pk_only=True is used if you want to be able to update nested field by using pk/id only. This applies to foreign key relations only as well. The default value for accept_pk_only kwarg is False , if accept_pk_only=True is set you won't be able to send data to create a nested resource. Below is an example showing how to use accept_pk_only kwarg. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # pk based nested field location = NestedField ( LocationSerializer , accept_pk_only = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] Sending mutation request POST /api/property/ Request Body { \"price\" : 40000 , \"location\" : 2 // You can't send data in here, you can only send pk/id } Response { \"id\" : 1 , \"price\" : 40000 , \"location\" : { \"id\" : 2 , \"city\" : \"Tokyo\" , \"country\" : \"China\" } } Note By default accept_pk=False and accept_pk_only=False , so nested field(foreign key related) accepts data only by default, if accept_pk=True is set, it accepts data and pk/id, and if accept_pk_only=True is set it accepts pk/id only. You can't set both accept_pk=True and accept_pk_only=True .","title":"accept_pk_only kwarg"},{"location":"mutating_data/#create_ops-and-update_ops-kwargs","text":"These two kwargs are used to restrict some operations when creating or updating nested data. Below is an example showing how to restrict some operations by using these two kwargs. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.serializers import NestedModelSerializer from app.models import Location , Amenity , Property class AmenitySerializer ( serializers . ModelSerializer ): class Meta : model = Amenity fields = [ \"id\" , \"name\" ] class PropertySerializer ( NestedModelSerializer ): amenities = NestedField ( AmenitySerializer , many = True , create_ops = [ \"add\" ], # Allow only add operation update_ops = [ \"add\" , \"remove\" ] # Allow only add and remove operations ) class Meta : model = Property fields = [ 'id' , 'price' , 'amenities' ] Sending create mutation request POST /api/property/ Request Body { \"price\" : 60000 , \"amenities\" : { \"add\" : [ 1 , 2 ] } } Note Since create_ops=[\"add\"] , you can't use create operation in here!. Response { \"id\" : 2 , \"price\" : 60000 , \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Watererr\" }, { \"id\" : 2 , \"name\" : \"Electricity\" } ] } Sending update mutation request PUT/PATCH /api/property/2/ Request Body { \"price\" : 50000 , \"amenities\" : { \"add\" : [ 3 ], \"remove\" : [ 2 ] } } Note Since update_ops=[\"add\", \"remove\"] , you can't use create or update operation in here!. Response { \"id\" : 2 , \"price\" : 50000 , \"amenities\" : [ { \"id\" : 1 , \"name\" : \"Water\" }, { \"id\" : 3 , \"name\" : \"Bathtub\" } ] }","title":"create_ops and update_ops kwargs."},{"location":"mutating_data/#allow_remove_all-kwarg","text":"This kwarg is used to enable and disable removing all related objects on many related nested field at once by using __all__ directive. The default value of allow_remove_all is False , which means removing all related objects on many related nested fields is disabled by default so if you want to enable it you must set its value to True . For example class CourseSerializer ( NestedModelSerializer ): books = NestedField ( BookSerializer , many = True , allow_remove_all = True ) class Meta : model = Course fields = [ \"name\" , \"code\" , \"books\" ] With allow_remove_all=True as set above you will be able to send a request like PUT/PATCH /courses/3/ Request Body { \"books\" : { \"remove\" : \"__all__\" } } This will remove all books associated with a course being updated.","title":"allow_remove_all kwarg"},{"location":"mutating_data/#using-dynamicfieldsmixin-and-nestedfield-together","text":"You can use DynamicFieldsMixin and NestedModelSerializer together if you want your serializer to be writable(on nested fields) and support querying data, this is very common. Below is an example which shows how you can use DynamicFieldsMixin and NestedField together. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] # Inherit both DynamicFieldsMixin and NestedModelSerializer class PropertySerializer ( DynamicFieldsMixin , NestedModelSerializer ): location = NestedField ( LocationSerializer ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] NestedField is nothing but a serializer wrapper, it returns an instance of a modified version of a serializer passed, so you can pass all the args and kwargs accepted by a serializer on it, it will simply pass them along to a serializer passed when instantiating an instance. So you can pass anything accepted by a serializer to a NestedField wrapper, and if a serializer passed inherits DynamicFieldsMixin just like LocationSerializer on the example above then you can pass any arg or kwarg accepted by DynamicFieldsMixin when defining location as a nested field, i.e location = NestedField ( LocationSerializer , fields = [ ... ]) location = NestedField ( LocationSerializer , exclude = [ ... ]) location = NestedField ( LocationSerializer , return_pk = True ) Note If you want to use required=False kwarg on NestedField you might want to include allow_null=True too if you want your nested field to be set to null if you haven't supplied it. For example from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Location , Property class LocationSerializer ( serializers . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" ] class PropertySerializer ( NestedModelSerializer ): # Passing both `required=False` and `allow_null=True` location = NestedField ( LocationSerializer , required = False , allow_null = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] The required=False kwarg allows you to create Property without including location field and the allow_null=True kwarg allows location field to be set to null if you haven't supplied it. For example Sending mutation request POST /api/property/ Request Body { \"price\" : 40000 // You can see that the location is not included here } Response { \"id\" : 2 , \"price\" : 50000 , \"location\" : null // This is the result of not including location } If you use required=False only without allow_null=True , The serializer will allow you to create Property without including location field but it will throw error because by default allow_null=False which means null / None (which is what's passed when you don't supply location value) is not considered a valid value.","title":"Using DynamicFieldsMixin and NestedField together"},{"location":"mutating_data/#working-with-data-mutation-without-request","text":"Django RESTQL allows you to do data mutation without having request object, this is used if you don't want to get your mutation data input(serializer data) from a request, in fact NestedModelSerializer and NestedFied can work independently without using request. Below is an example showing how you can work with data mutation without request object. from rest_framework import serializers from django_restql.fields import NestedField from django_restql.mixins import DynamicFieldsMixin from django_restql.serializers import NestedModelSerializer from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , NestedModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , NestedModelSerializer ): books = NestedField ( BookSerializer , many = True , required = False ) class Meta : model = Course fields = [ 'id' , 'name' , 'code' , 'books' ] From serializers above you can create a course like data = { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : { \"add\" : [ 1 , 2 ], \"create\" : [ { 'title' : 'Basic Data Structures' , 'author' : 'J. Davis' }, { 'title' : 'Advanced Data Structures' , 'author' : 'S. Mobit' } ] } } serializer = CourseSerializer ( data = data ) serializer . is_valid () serializer . save () print ( serializer . data ) # This will print { \"id\" : 2 , \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { 'id' : 1 , 'title' : 'Programming Intro' , 'author' : 'K. Moses' }, { 'id' : 2 , 'title' : 'Understanding Computers' , 'author' : 'B. Gibson' }, { 'id' : 3 , 'title' : 'Basic Data Structures' , 'author' : 'J. Davis' }, { 'id' : 4 , 'title' : 'Advanced Data Structures' , 'author' : 'S. Mobit' } ] } To update a created course you can do it like data = { \"code\" : \"CS100\" , \"books\" : { \"remove\" : [ 2 , 3 ] } } course_obj = Course . objects . get ( pk = 2 ) serializer = CourseSerializer ( course_obj , data = data ) serializer . is_valid () serializer . save () print ( serializer . data ) # This will print { \"id\" : 2 , \"name\" : \"Computer Programming\" , \"code\" : \"CS100\" , \"books\" : [ { 'id' : 1 , 'title' : 'Programming Intro' , 'author' : 'K. Moses' }, { 'id' : 2 , 'title' : 'Understanding Computers' , 'author' : 'B. Gibson' } ] }","title":"Working with data mutation without request"},{"location":"querying_data/","text":"Querying Data \u00b6 Django RESTQL makes data querying(selecting fields to include in a response) way easier, if you want to use it to query data you just have to inherit the DynamicFieldsMixin class when defining your serializer, that's all. Below is an example showing how to use DynamicFieldsMixin . from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = User fields = [ 'id' , 'username' , 'email' ] Here a regular request returns all fields as specified on a DRF serializer, in fact Django RESTQL doesn't handle this(regular) request at all. Below is an example of a regular request and its response GET /users [ { \"id\" : 1 , \"username\" : \"yezyilomo\" , \"email\" : \"yezileliilomo@hotmail.com\" , }, ... ] As you can see all fields have been returned as specified on UserSerializer . Django RESTQL handle all requests with a query parameter, this parameter is the one which is used to pass all fields to be included/excluded in a response. For example to select id and username fields from User model, send a request with a query parameter as shown below. GET /users/?query={id, username} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" }, ... ] You can see only id and username fields have been returned in a response as specified on a query parameter. Querying nested fields \u00b6 Django RESTQL support querying both flat and nested data, so you can expand or query nested fields at any level as defined on a serializer. In an example below we have location and groups as nested fields on User model. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin from app.models import GroupSerializer , LocationSerializer class GroupSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Group fields = [ 'id' , 'name' ] class LocationSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Location fields = [ 'id' , 'country' , 'city' , 'street' ] class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): groups = GroupSerializer ( many = True , read_only = True ) location = LocationSerializer ( many = False , read_only = True ) class Meta : model = User fields = [ 'id' , 'username' , 'email' , 'location' , 'groups' ] If you want to retrieve user's id , username and location fields but under location field you want to get only country and city fields here is how you can do it GET /users/?query={id, username, location{country, city}} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" , \"location\" : { \"contry\" : \"Tanzania\" , \"city\" : \"Dar es salaam\" } }, ... ] More examples to get you comfortable with the query syntax GET /users/?query={location, groups} [ { \"location\" : { \"id\" : 1 , \"contry\" : \"Tanzania\" , \"city\" : \"Dar es salaam\" , \"street\" : \"Oyster Bay\" } \"groups\" : [ { \"id\" : 2 , \"name\" : \"Auth_User\" }, { \"id\" : 3 , \"name\" : \"Admin_User\" } ] }, ... ] GET /users/?query={id, username, groups{name}} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" , \"groups\" : [ { \"name\" : \"Auth_User\" }, { \"name\" : \"Admin_User\" } ] }, ... ] Note Using commas( , ) to separate fields and arguments is optional, you can use spaces too just like in GraphQL For example you could write your query as query={id username location{country city}} so the choice is yours. Exclude(-) operator \u00b6 Using Django RESTQL filtering as it is when there are no many fields on a serializer is great, but sometimes you might have a case where you would like everything except a handful of fields on a larger serializer. These fields might be nested and trying the whitelist approach might possibly be too long for the url. Django RESTQL comes with the exclude(-) operator which can be used to exclude some fields in scenarios where you want to get all fields except few ones. Using exclude operator is very simple, you just need to prepend the exclude(-) operator to the field which you want to exclude when writing your query that's all. Take an example below from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Location , Property class LocationSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" , \"state\" , \"street\" ] class PropertySerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): location = LocationSerializer ( many = False , read_only = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] If we want to get all fields under LocationSerializer except id and street , by using the exclude(-) operator we could do it as follows GET /location/?query={-id, -street} [ { \"country\" : \"China\" , \"city\" : \"Beijing\" , \"state\" : \"Chaoyang\" }, ... ] This is equivalent to query={country, city, state} You can use exclude operator on nested fields too, for example if you want to get price and location fields but under location you want all fields except id here is how you could do it. GET /property/?query={price, location{-id}} [ { \"price\" : 5000 \"location\" : { \"country\" : \"China\" , \"city\" \"Beijing\" , \"state\" : \"Chaoyang\" , \"street\" : \"Hanang\" } }, ... ] This is equivalent to query={price, location{country, city, state, street}} More examples to get you comfortable with the exclude(-) operator Assuming this is the structure of the model we are querying data = { username , birthdate , location { country , city }, contact { phone , email } } Here is how we can structure our queries to exclude some fields by using exclude(-) operator { - username } \u2261 { birthdate , location { country , city }, contact { phone , email }} { - username , contact { phone }, location { country }} \u2261 { birthdate , contact { phone }, location { country }} { - contact , location { country }} \u2261 { username , birthdate , location { country }} { - contact , - location } \u2261 { username , birthdate } { username , location { - country }} \u2261 { username , location { city }} { username , location { - city }, contact { - email }} \u2261 { username , location { country }, contact { phone }} Wildcard(*) operator \u00b6 In addition to the exclude(-) operator, Django RESTQL comes with a wildcard(*) operator for including all fields. Using a wildcard(*) operator is very simple, for example if you want to get all fields from a model by using a wildcard(*) operator you could simply write your query as query={*} This operator can be used to simplify some filtering which might endup being very long if done with other approaches. For example if you have a model with this format user = { username , birthdate , contact { phone , email , twitter , github , linkedin , facebook } } Let's say you want to get all user fields but under contact field you want to get only phone , you could use the whitelisting approach and write your query as query={username, birthdate, contact{phone}} but if you have many fields on user model you might endup writing a very long query, such problem can be avoided by using a wildcard(*) operator which in our case we could simply write the query as query={*, contact{phone}} The above query means \"get me all fields on user model but under contact field get only phone field\". As you can see the query became very short compared to the first one after using wildcard(*) operator and it won't grow if more fields are added to a user model. More examples to get you comfortable with the wildcard(*) operator { * , - username , contact { phone }} \u2261 { birthdate , contact { phone }} { username , contact { * , - facebook , - linkedin }} \u2261 { username , contact { phone , email , twitter , github }} { * , - username , contact { * , - facebook , - linkedin }} \u2261 { birthdate , contact { phone , email , twitter , github }} Below is a list of mistakes which leads to query syntax/format error, these mistakes may happen accidentally as it's very easy/tempting to make them with the exclude(-) operator and wildcard(*) operator syntax. { username , - location { country }} # Should not expand excluded field { * username } # What are you even trying to accomplish { * location { country }} # This is definitely wrong Aliases \u00b6 When working with API, you may want to rename a field to something other than what the API has to offer. Aliases exist as part of this library to solve this exact problem. Aliases allow you to rename a single field to whatever you want it to be. They are defined at the client side, so you don\u2019t need to update your API to use them. Imagine requesting data using the following query from an API: GET /users/?query={id, updated_at} You will get the following JSON response: [ { \"id\" : 1 , \"updated_at\" : \"2021-05-05T21:05:23.034Z\" }, ... ] The id here is fine, but the updated_at doesn\u2019t quite conform to the camel case convention in JavaScript(Which is where APIs are used mostly). Let\u2019s change it by using an alias. GET /users/?query={id, updatedAt: updated_at} Which yields the following: [ { \"id\" : 1 , \"updatedAt\" : \"2021-05-05T21:05:23.034Z\" }, ... ] Creating an alias is very easy just like in GraphQL . Simply add a new name and a colon(:) before the field you want to rename. More examples Renaming date_of_birth to dateOfBirth , course to programme and books to readings GET /students/?query={name, dateOfBirth: date_of_birth, programme: course{id, name, readings: books}} This yields [ { \"name\" : \"Yezy Ilomo\" , \"dateOfBirth\" : \"04-08-1995\" , \"programme\" : { \"id\" : 4 , \"name\" : \"Computer Science\" , \"readings\" : [ { \"id\" : 1 , \"title\" : \"Alogarithms\" }, { \"id\" : 2 , \"title\" : \"Data Structures\" }, ] } }, ... ] Note The default maximum length of alias is 50 characters, it's controlled by MAX_ALIAS_LEN setting. This is enforced to prevent DoS like attacks to API which might be caused by clients specifying a really really long alias which may increase network usage. For more information about MAX_ALIAS_LEN setting and how to change it go to this section . DynamicSerializerMethodField \u00b6 DynamicSerializerMethodField is a wraper of the SerializerMethodField , it adds a parsed query argument from a parent serializer to a method bound to a SerializerMethodField , this parsed query argument can be passed to a serializer used within a method to allow further querying. For example in the scenario below we are using DynamicSerializerMethodField because we want to be able to query related_books field. from django_restql.mixins import DynamicFieldsMixin from django_restql.fields import DynamicSerializerMethodField class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): # Use `DynamicSerializerMethodField` instead of `SerializerMethodField` # if you want to be able to query `related_books` related_books = DynamicSerializerMethodField () class Meta : model = Course fields = [ 'name' , 'code' , 'related_books' ] def get_related_books ( self , obj , parsed_query ): # With `DynamicSerializerMethodField` you get this extra # `parsed_query` argument in addition to `obj` books = obj . books . all () # You can do what ever you want in here # `parsed_query` param is passed to BookSerializer to allow further querying serializer = BookSerializer ( books , many = True , parsed_query = parsed_query ) return serializer . data GET /course/?query={name, related_books} [ { \"name\" : \"Data Structures\" , \"related_books\" : [ { \"title\" : \"Advanced Data Structures\" , \"author\" : \"S.Mobit\" }, { \"title\" : \"Basic Data Structures\" , \"author\" : \"S.Mobit\" } ] } ] GET /course/?query={name, related_books{title}} [ { \"name\" : \"Data Structures\" , \"related_books\" : [ { \"title\" : \"Advanced Data Structures\" }, { \"title\" : \"Basic Data Structures\" } ] } ] DynamicFieldsMixin kwargs \u00b6 DynamicFieldsMixin accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a serializer as explained below. fields kwarg \u00b6 With Django RESTQL you can specify fields to be included when instantiating a serializer, this provides a way to refilter fields on nested fields(i.e you can opt to remove some fields on a nested field). Below is an example which shows how you can specify fields to be included on nested resources. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , fields = [ \"title\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /courses/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] As you see from the response above, the nested resource(book) has only one field(title) as specified on fields=[\"title\"] kwarg during instantiating BookSerializer, so if you send a request like GET /course?query={name, code, books{title, author}} you will get an error that author field is not found because it was not included here fields=[\"title\"] . exclude kwarg \u00b6 You can also specify fields to be excluded when instantiating a serializer by using exclude kwarg, below is an example which shows how to use exclude kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /courses/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" }, { \"id\" : 2 , \"title\" : \"Data structures\" } ] }, ... ] From the response above you can see that author field has been excluded fom book nested resource as specified on exclude=[\"author\"] kwarg during instantiating BookSerializer. Note fields and exclude kwargs have no effect when you access the resources directly, so when you access books you will still get all fields i.e GET /books/ [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" , \"author\" : \"S.Mobit\" }, ... ] So you can see that all fields have appeared as specified on fields = ['id', 'title', 'author'] on BookSerializer class. query kwarg \u00b6 Django RESTQL allows you to query fields by using query kwarg too, this is used if you don't want to get your query string from a request parameter, in fact DynamicFieldsMixin can work independently without using request. So by using query kwarg if you have serializers like from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] You can query fields as objs = Course . objects . all () query = \"{name, books {title} }\" serializer = CourseSerializer ( objs , many = True , query = query ) print ( serializer . data ) # This will print [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] As you see this doesn't need a request or view to work, you can use it anywhere as long as you pass your query string to a query kwarg. parsed_query kwarg \u00b6 In addition to query kwarg, Django RESTQL allows you to query fields by using parsed_query kwarg. Here parsed_query is a query which has been parsed by a QueryParser . You probably won't need to use this directly as you are not adviced to write parsed query yourself, so the value of parsed_query kwarg should be something coming from QueryParser . If you have serializers like from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] You can query fields by using parsed_query kwarg as follows import QueryParser from django_restql.parser objs = Course . objects . all () query = \"{name, books {title} }\" # You have to parse your query string first parser = QueryParser () parsed_query = parser . parse ( query ) serializer = CourseSerializer ( objs , many = True , parsed_query = parsed_query ) print ( serializer . data ) # This will print [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] parsed_query kwarg is often used with DynamicMethodField to pass part of parsed query to nested fields to allow further querying. return_pk kwarg \u00b6 With Django RESTQL you can specify whether to return nested resource pk or data. Below is an example which shows how we can use return_pk kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , return_pk = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /course/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ 1 , 2 ] }, ... ] So you can see that on a nested field books pks have been returned instead of books data as specified on return_pk=True kwarg on BookSerializer . disable_dynamic_fields kwarg \u00b6 Sometimes there are cases where you want to disable fields filtering with on a specific nested field, Django RESTQL allows you to do so by using disable_dynamic_fields kwarg when instantiating a serializer. Below is an example which shows how to use disable_dynamic_fields kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): # Disable fields filtering on this field books = BookSerializer ( many = True , read_only = True , disable_dynamic_fields = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /course/?query={name, books{title}} [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" , \"author\" : \"J.Vough\" }, { \"id\" : 2 , \"title\" : \"Data structures\" , \"author\" : \"D.Denis\" } ] }, ... ] So you can see that even though the query asked for only title field under books , all fields have been returned, so this means fields filtering has applied on CourseSerializer but not on BookSerializer because we used disable_dynamic_fields=True on it. Query arguments \u00b6 Just like GraphQL, Django RESTQL allows you to pass arguments. These arguments can be used to do filtering, pagination, sorting and other stuffs that you would like them to do. Below is a syntax for passing arguments query = (age: 18){ name, age, location(country: Canada, city: Toronto){ country, city } } Here we have three arguments, age , country and city and their corresponding values. To escape any special character in a string(including , : \" ' {} () ) use backslash \\ , single quote ' or double quote \" , also if you want to escape double quote you can use single quote and vice versa. Escaping is very useful if you are dealing with data containing special characters e.g time, dates, lists, texts etc. Below is an example which contain an argument with a date type. query = (age: 18, join_date__lt: '2020-04-27T23:02:32Z'){ name, age, location(country: 'Canada', city: 'Toronto'){ country, city } } Query arguments data types \u00b6 Django RESTQL supports five primitive data types for query arguments which are String , Int , Float , Boolean , and null The table below shows possible argument values and their corresponding python values Argument Value Python Value String(e.g \"Hi!\" or 'Hi!') Python String(e.g \"Hi!\" or 'Hi!') Int(e.g 25) Python Int(e.g 25) Float(e.g 25.34) Python Float(e.g 25.34) true True false False null None Below is a query showing how these data types are used query = (age__gt: 18, is_active: true, location__ne: null, height__gt: 5.4){ name, age, location(country: \"Canada\"){ country, city } } Filtering & pagination with query arguments \u00b6 As mentioned before you can use query arguments to do filtering and pagination, Django RESTQL itself doesn't do filtering or pagination but it can help you to convert query arguments into query parameters from there you can use any library which you want to do the actual filtering or any pagination class to do pagination as long as they work with query parameters. To convert query arguments into query parameters all you need to do is inherit QueryArgumentsMixin in your viewset, that's it. For example # views.py from rest_framework import viewsets from django_restql.mixins import QueryArgumentsMixin class StudentViewSet ( QueryArgumentsMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () filter_fields = { 'name' : [ 'exact' ], 'age' : [ 'exact' ], 'location__country' : [ 'exact' ], 'location__city' : [ 'exact' ], } Whether you are using django-filter or djangorestframework-filters or any filter backend to do the actual filtering, Once you've configured it, you can continue to use all of the features found in filter backend of your choise as usual. The purpose of Django RESTQL on filtering is only to generate query parameters form query arguments. For example if you have a query like query = (age: 18){ name, age, location(country: Canada, city: Toronto){ country, city } } Django RESTQL would generate three query parameters from this as shown below query_params = { \"age\" : 18 , \"location__country\" : \"Canada\" , \"location__city\" : \"Toronto\" } These will be used by the filter backend you have set to do the actual filtering. The same applies to pagination, sorting etc, once you have configured your pagination class whether it's PageNumberPagination , LimitOffsetPagination , CursorPagination or a custom, you will be able do it with query arguments. For example if you're using LimitOffsetPagination and you have a query like query = (limit: 20, offset: 50){ name, age, location{ country, city } } Django RESTQL would generate two query parameters from this as shown below query_params = { \"limit\" : 20 , \"offset\" : 50 } These will be used by pagination class you have set to do the actual pagination. So to use query arguments as query parameters all you need to do is inherit QueryArgumentsMixin to your viewset to convert query arguments into query parameters, from there you can use whatever you want to accomplish whatever with those generated query parameters. Setting up eager loading \u00b6 Often times, using prefetch_related or select_related on a view queryset can help speed up the serialization. For example, if you had a many-to-many relation like Books to a Course, it's usually more efficient to call prefetch_related on the books so that serializing a list of courses only triggers one additional query, instead of a number of queries equal to the number of courses. EagerLoadingMixin gives access to prefetch_related and select_related properties, these two are dictionaries that match serializer field names to respective values that would be passed into prefetch_related or select_related . Take the following serializers as examples. class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] class StudentSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): program = CourseSerializer ( source = \"course\" , many = False , read_only = True ) phone_numbers = PhoneSerializer ( many = True , read_only = True ) class Meta : model = Student fields = [ 'name' , 'age' , 'program' , 'phone_numbers' ] In a view, these can be used as described earlier in this documentation. However, if prefetching of books always happened, but we did not ask for {program} or program{books} , then we did an additional query for nothing. Conversely, not prefetching can lead to even more queries being triggered. When leveraging the EagerLoadingMixin on a view, the specific fields that warrant a select_related or prefetch_related can be described. Syntax for prefetch_related and select_related \u00b6 The format of syntax for select_related and prefetch_related is as follows select_related = { \"serializer_field_name\" : [ \"field_to_select\" ]} prefetch_related = { \"serializer_field_name\" : [ \"field_to_prefetch\" ]} If you are selecting or prefetching one field per serializer field name you can use select_related = { \"serializer_field_name\" : \"field_to_select\" } prefetch_related = { \"serializer_field_name\" : \"field_to_prefetch\" } Syntax Interpretation serializer_field_name stands for the name of the field to prefetch or select(as named on a serializer). fields_to_select stands for argument(s) to pass when calling select_related method. fields_to_prefetch stands for arguments(s) to pass when calling prefetch_related method. This can be a string or Prefetch object. If you want to select or prefetch nested field use dot(.) to separate parent and child fields on serializer_field_name eg parent.child . Example of EagerLoadingMixin usage \u00b6 from rest_framework import viewsets from django_restql.mixins import EagerLoadingMixin from myapp.serializers import StudentSerializer from myapp.models import Student class StudentViewSet ( EagerLoadingMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () # The Interpretation of this is # Select `course` only if program field is included in a query select_related = { \"program\" : \"course\" } # The Interpretation of this is # Prefetch `course__books` only if program or program.books # fields are included in a query prefetch_related = { \"program.books\" : \"course__books\" } Example Queries {name} : Neither select_related or prefetch_related will be run since neither field is present on the serializer for this query. {program} : Both select_related and prefetch_related will be run, since program is present in it's entirety (including the books field). {program{name}} : Only select_related will be run, since books are not present on the program fields. {program{books}} : Both will be run here as well, since this explicitly fetches books. More example to get you comfortable with the syntax Assuming this is the structure of the model and corresponding field types user = { username , # string birthdate , # string location { # foreign key related field country , # string city # string }, contact { # foreign key related field email , # string phone { # foreign key related field number , # string type # string } } articles { # many related field title , # string body , # text reviews { # many related field comment , # string rating # number } } } Here is how select_related and prefetch_related could be written for this model select_related = { \"location\" : \"location\" , \"contact\" : \"contact\" , \"contact.phone\" : \"contact__phone\" } prefetch_related = { \"articles\" : Prefetch ( \"articles\" , queryset = Article . objects . all ()), \"articles.reviews\" : \"articles__reviews\" } Known Caveats \u00b6 When prefetching with a to_attr , ensure that there are no collisions. Django does not allow multiple prefetches with the same to_attr on the same queryset. When prefetching and calling select_related on a field, Django may error, since the ORM does allow prefetching a selectable field, but not both at the same time.","title":"Querying Data"},{"location":"querying_data/#querying-data","text":"Django RESTQL makes data querying(selecting fields to include in a response) way easier, if you want to use it to query data you just have to inherit the DynamicFieldsMixin class when defining your serializer, that's all. Below is an example showing how to use DynamicFieldsMixin . from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = User fields = [ 'id' , 'username' , 'email' ] Here a regular request returns all fields as specified on a DRF serializer, in fact Django RESTQL doesn't handle this(regular) request at all. Below is an example of a regular request and its response GET /users [ { \"id\" : 1 , \"username\" : \"yezyilomo\" , \"email\" : \"yezileliilomo@hotmail.com\" , }, ... ] As you can see all fields have been returned as specified on UserSerializer . Django RESTQL handle all requests with a query parameter, this parameter is the one which is used to pass all fields to be included/excluded in a response. For example to select id and username fields from User model, send a request with a query parameter as shown below. GET /users/?query={id, username} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" }, ... ] You can see only id and username fields have been returned in a response as specified on a query parameter.","title":"Querying Data"},{"location":"querying_data/#querying-nested-fields","text":"Django RESTQL support querying both flat and nested data, so you can expand or query nested fields at any level as defined on a serializer. In an example below we have location and groups as nested fields on User model. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin from app.models import GroupSerializer , LocationSerializer class GroupSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Group fields = [ 'id' , 'name' ] class LocationSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Location fields = [ 'id' , 'country' , 'city' , 'street' ] class UserSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): groups = GroupSerializer ( many = True , read_only = True ) location = LocationSerializer ( many = False , read_only = True ) class Meta : model = User fields = [ 'id' , 'username' , 'email' , 'location' , 'groups' ] If you want to retrieve user's id , username and location fields but under location field you want to get only country and city fields here is how you can do it GET /users/?query={id, username, location{country, city}} [ { \"id\" : 1 , \"username\" : \"yezyilomo\" , \"location\" : { \"contry\" : \"Tanzania\" , \"city\" : \"Dar es salaam\" } }, ... ]","title":"Querying nested fields"},{"location":"querying_data/#exclude-operator","text":"Using Django RESTQL filtering as it is when there are no many fields on a serializer is great, but sometimes you might have a case where you would like everything except a handful of fields on a larger serializer. These fields might be nested and trying the whitelist approach might possibly be too long for the url. Django RESTQL comes with the exclude(-) operator which can be used to exclude some fields in scenarios where you want to get all fields except few ones. Using exclude operator is very simple, you just need to prepend the exclude(-) operator to the field which you want to exclude when writing your query that's all. Take an example below from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Location , Property class LocationSerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): class Meta : model = Location fields = [ \"id\" , \"city\" , \"country\" , \"state\" , \"street\" ] class PropertySerializer ( DynamicFieldsMixin , serializer . ModelSerializer ): location = LocationSerializer ( many = False , read_only = True ) class Meta : model = Property fields = [ 'id' , 'price' , 'location' ] If we want to get all fields under LocationSerializer except id and street , by using the exclude(-) operator we could do it as follows GET /location/?query={-id, -street} [ { \"country\" : \"China\" , \"city\" : \"Beijing\" , \"state\" : \"Chaoyang\" }, ... ] This is equivalent to query={country, city, state} You can use exclude operator on nested fields too, for example if you want to get price and location fields but under location you want all fields except id here is how you could do it. GET /property/?query={price, location{-id}} [ { \"price\" : 5000 \"location\" : { \"country\" : \"China\" , \"city\" \"Beijing\" , \"state\" : \"Chaoyang\" , \"street\" : \"Hanang\" } }, ... ] This is equivalent to query={price, location{country, city, state, street}}","title":"Exclude(-) operator"},{"location":"querying_data/#wildcard-operator","text":"In addition to the exclude(-) operator, Django RESTQL comes with a wildcard(*) operator for including all fields. Using a wildcard(*) operator is very simple, for example if you want to get all fields from a model by using a wildcard(*) operator you could simply write your query as query={*} This operator can be used to simplify some filtering which might endup being very long if done with other approaches. For example if you have a model with this format user = { username , birthdate , contact { phone , email , twitter , github , linkedin , facebook } } Let's say you want to get all user fields but under contact field you want to get only phone , you could use the whitelisting approach and write your query as query={username, birthdate, contact{phone}} but if you have many fields on user model you might endup writing a very long query, such problem can be avoided by using a wildcard(*) operator which in our case we could simply write the query as query={*, contact{phone}} The above query means \"get me all fields on user model but under contact field get only phone field\". As you can see the query became very short compared to the first one after using wildcard(*) operator and it won't grow if more fields are added to a user model.","title":"Wildcard(*) operator"},{"location":"querying_data/#aliases","text":"When working with API, you may want to rename a field to something other than what the API has to offer. Aliases exist as part of this library to solve this exact problem. Aliases allow you to rename a single field to whatever you want it to be. They are defined at the client side, so you don\u2019t need to update your API to use them. Imagine requesting data using the following query from an API: GET /users/?query={id, updated_at} You will get the following JSON response: [ { \"id\" : 1 , \"updated_at\" : \"2021-05-05T21:05:23.034Z\" }, ... ] The id here is fine, but the updated_at doesn\u2019t quite conform to the camel case convention in JavaScript(Which is where APIs are used mostly). Let\u2019s change it by using an alias. GET /users/?query={id, updatedAt: updated_at} Which yields the following: [ { \"id\" : 1 , \"updatedAt\" : \"2021-05-05T21:05:23.034Z\" }, ... ] Creating an alias is very easy just like in GraphQL . Simply add a new name and a colon(:) before the field you want to rename.","title":"Aliases"},{"location":"querying_data/#dynamicserializermethodfield","text":"DynamicSerializerMethodField is a wraper of the SerializerMethodField , it adds a parsed query argument from a parent serializer to a method bound to a SerializerMethodField , this parsed query argument can be passed to a serializer used within a method to allow further querying. For example in the scenario below we are using DynamicSerializerMethodField because we want to be able to query related_books field. from django_restql.mixins import DynamicFieldsMixin from django_restql.fields import DynamicSerializerMethodField class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): # Use `DynamicSerializerMethodField` instead of `SerializerMethodField` # if you want to be able to query `related_books` related_books = DynamicSerializerMethodField () class Meta : model = Course fields = [ 'name' , 'code' , 'related_books' ] def get_related_books ( self , obj , parsed_query ): # With `DynamicSerializerMethodField` you get this extra # `parsed_query` argument in addition to `obj` books = obj . books . all () # You can do what ever you want in here # `parsed_query` param is passed to BookSerializer to allow further querying serializer = BookSerializer ( books , many = True , parsed_query = parsed_query ) return serializer . data GET /course/?query={name, related_books} [ { \"name\" : \"Data Structures\" , \"related_books\" : [ { \"title\" : \"Advanced Data Structures\" , \"author\" : \"S.Mobit\" }, { \"title\" : \"Basic Data Structures\" , \"author\" : \"S.Mobit\" } ] } ] GET /course/?query={name, related_books{title}} [ { \"name\" : \"Data Structures\" , \"related_books\" : [ { \"title\" : \"Advanced Data Structures\" }, { \"title\" : \"Basic Data Structures\" } ] } ]","title":"DynamicSerializerMethodField"},{"location":"querying_data/#dynamicfieldsmixin-kwargs","text":"DynamicFieldsMixin accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a serializer as explained below.","title":"DynamicFieldsMixin kwargs"},{"location":"querying_data/#fields-kwarg","text":"With Django RESTQL you can specify fields to be included when instantiating a serializer, this provides a way to refilter fields on nested fields(i.e you can opt to remove some fields on a nested field). Below is an example which shows how you can specify fields to be included on nested resources. from rest_framework import serializers from django.contrib.auth.models import User from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , fields = [ \"title\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /courses/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] As you see from the response above, the nested resource(book) has only one field(title) as specified on fields=[\"title\"] kwarg during instantiating BookSerializer, so if you send a request like GET /course?query={name, code, books{title, author}} you will get an error that author field is not found because it was not included here fields=[\"title\"] .","title":"fields kwarg"},{"location":"querying_data/#exclude-kwarg","text":"You can also specify fields to be excluded when instantiating a serializer by using exclude kwarg, below is an example which shows how to use exclude kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /courses/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" }, { \"id\" : 2 , \"title\" : \"Data structures\" } ] }, ... ] From the response above you can see that author field has been excluded fom book nested resource as specified on exclude=[\"author\"] kwarg during instantiating BookSerializer. Note fields and exclude kwargs have no effect when you access the resources directly, so when you access books you will still get all fields i.e GET /books/ [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" , \"author\" : \"S.Mobit\" }, ... ] So you can see that all fields have appeared as specified on fields = ['id', 'title', 'author'] on BookSerializer class.","title":"exclude kwarg"},{"location":"querying_data/#query-kwarg","text":"Django RESTQL allows you to query fields by using query kwarg too, this is used if you don't want to get your query string from a request parameter, in fact DynamicFieldsMixin can work independently without using request. So by using query kwarg if you have serializers like from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] You can query fields as objs = Course . objects . all () query = \"{name, books {title} }\" serializer = CourseSerializer ( objs , many = True , query = query ) print ( serializer . data ) # This will print [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] As you see this doesn't need a request or view to work, you can use it anywhere as long as you pass your query string to a query kwarg.","title":"query kwarg"},{"location":"querying_data/#parsed_query-kwarg","text":"In addition to query kwarg, Django RESTQL allows you to query fields by using parsed_query kwarg. Here parsed_query is a query which has been parsed by a QueryParser . You probably won't need to use this directly as you are not adviced to write parsed query yourself, so the value of parsed_query kwarg should be something coming from QueryParser . If you have serializers like from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , exclude = [ \"author\" ]) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] You can query fields by using parsed_query kwarg as follows import QueryParser from django_restql.parser objs = Course . objects . all () query = \"{name, books {title} }\" # You have to parse your query string first parser = QueryParser () parsed_query = parser . parse ( query ) serializer = CourseSerializer ( objs , many = True , parsed_query = parsed_query ) print ( serializer . data ) # This will print [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"title\" : \"Computer Programming Basics\" }, { \"title\" : \"Data structures\" } ] }, ... ] parsed_query kwarg is often used with DynamicMethodField to pass part of parsed query to nested fields to allow further querying.","title":"parsed_query kwarg"},{"location":"querying_data/#return_pk-kwarg","text":"With Django RESTQL you can specify whether to return nested resource pk or data. Below is an example which shows how we can use return_pk kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True , return_pk = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /course/ [ { \"name\" : \"Computer Programming\" , \"code\" : \"CS50\" , \"books\" : [ 1 , 2 ] }, ... ] So you can see that on a nested field books pks have been returned instead of books data as specified on return_pk=True kwarg on BookSerializer .","title":"return_pk kwarg"},{"location":"querying_data/#disable_dynamic_fields-kwarg","text":"Sometimes there are cases where you want to disable fields filtering with on a specific nested field, Django RESTQL allows you to do so by using disable_dynamic_fields kwarg when instantiating a serializer. Below is an example which shows how to use disable_dynamic_fields kwarg. from rest_framework import serializers from django_restql.mixins import DynamicFieldsMixin from app.models import Book , Course class BookSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): class Meta : model = Book fields = [ 'id' , 'title' , 'author' ] class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): # Disable fields filtering on this field books = BookSerializer ( many = True , read_only = True , disable_dynamic_fields = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] GET /course/?query={name, books{title}} [ { \"name\" : \"Computer Programming\" , \"books\" : [ { \"id\" : 1 , \"title\" : \"Computer Programming Basics\" , \"author\" : \"J.Vough\" }, { \"id\" : 2 , \"title\" : \"Data structures\" , \"author\" : \"D.Denis\" } ] }, ... ] So you can see that even though the query asked for only title field under books , all fields have been returned, so this means fields filtering has applied on CourseSerializer but not on BookSerializer because we used disable_dynamic_fields=True on it.","title":"disable_dynamic_fields kwarg"},{"location":"querying_data/#query-arguments","text":"Just like GraphQL, Django RESTQL allows you to pass arguments. These arguments can be used to do filtering, pagination, sorting and other stuffs that you would like them to do. Below is a syntax for passing arguments query = (age: 18){ name, age, location(country: Canada, city: Toronto){ country, city } } Here we have three arguments, age , country and city and their corresponding values. To escape any special character in a string(including , : \" ' {} () ) use backslash \\ , single quote ' or double quote \" , also if you want to escape double quote you can use single quote and vice versa. Escaping is very useful if you are dealing with data containing special characters e.g time, dates, lists, texts etc. Below is an example which contain an argument with a date type. query = (age: 18, join_date__lt: '2020-04-27T23:02:32Z'){ name, age, location(country: 'Canada', city: 'Toronto'){ country, city } }","title":"Query arguments"},{"location":"querying_data/#query-arguments-data-types","text":"Django RESTQL supports five primitive data types for query arguments which are String , Int , Float , Boolean , and null The table below shows possible argument values and their corresponding python values Argument Value Python Value String(e.g \"Hi!\" or 'Hi!') Python String(e.g \"Hi!\" or 'Hi!') Int(e.g 25) Python Int(e.g 25) Float(e.g 25.34) Python Float(e.g 25.34) true True false False null None Below is a query showing how these data types are used query = (age__gt: 18, is_active: true, location__ne: null, height__gt: 5.4){ name, age, location(country: \"Canada\"){ country, city } }","title":"Query arguments data types"},{"location":"querying_data/#filtering-pagination-with-query-arguments","text":"As mentioned before you can use query arguments to do filtering and pagination, Django RESTQL itself doesn't do filtering or pagination but it can help you to convert query arguments into query parameters from there you can use any library which you want to do the actual filtering or any pagination class to do pagination as long as they work with query parameters. To convert query arguments into query parameters all you need to do is inherit QueryArgumentsMixin in your viewset, that's it. For example # views.py from rest_framework import viewsets from django_restql.mixins import QueryArgumentsMixin class StudentViewSet ( QueryArgumentsMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () filter_fields = { 'name' : [ 'exact' ], 'age' : [ 'exact' ], 'location__country' : [ 'exact' ], 'location__city' : [ 'exact' ], } Whether you are using django-filter or djangorestframework-filters or any filter backend to do the actual filtering, Once you've configured it, you can continue to use all of the features found in filter backend of your choise as usual. The purpose of Django RESTQL on filtering is only to generate query parameters form query arguments. For example if you have a query like query = (age: 18){ name, age, location(country: Canada, city: Toronto){ country, city } } Django RESTQL would generate three query parameters from this as shown below query_params = { \"age\" : 18 , \"location__country\" : \"Canada\" , \"location__city\" : \"Toronto\" } These will be used by the filter backend you have set to do the actual filtering. The same applies to pagination, sorting etc, once you have configured your pagination class whether it's PageNumberPagination , LimitOffsetPagination , CursorPagination or a custom, you will be able do it with query arguments. For example if you're using LimitOffsetPagination and you have a query like query = (limit: 20, offset: 50){ name, age, location{ country, city } } Django RESTQL would generate two query parameters from this as shown below query_params = { \"limit\" : 20 , \"offset\" : 50 } These will be used by pagination class you have set to do the actual pagination. So to use query arguments as query parameters all you need to do is inherit QueryArgumentsMixin to your viewset to convert query arguments into query parameters, from there you can use whatever you want to accomplish whatever with those generated query parameters.","title":"Filtering &amp; pagination with query arguments"},{"location":"querying_data/#setting-up-eager-loading","text":"Often times, using prefetch_related or select_related on a view queryset can help speed up the serialization. For example, if you had a many-to-many relation like Books to a Course, it's usually more efficient to call prefetch_related on the books so that serializing a list of courses only triggers one additional query, instead of a number of queries equal to the number of courses. EagerLoadingMixin gives access to prefetch_related and select_related properties, these two are dictionaries that match serializer field names to respective values that would be passed into prefetch_related or select_related . Take the following serializers as examples. class CourseSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): books = BookSerializer ( many = True , read_only = True ) class Meta : model = Course fields = [ 'name' , 'code' , 'books' ] class StudentSerializer ( DynamicFieldsMixin , serializers . ModelSerializer ): program = CourseSerializer ( source = \"course\" , many = False , read_only = True ) phone_numbers = PhoneSerializer ( many = True , read_only = True ) class Meta : model = Student fields = [ 'name' , 'age' , 'program' , 'phone_numbers' ] In a view, these can be used as described earlier in this documentation. However, if prefetching of books always happened, but we did not ask for {program} or program{books} , then we did an additional query for nothing. Conversely, not prefetching can lead to even more queries being triggered. When leveraging the EagerLoadingMixin on a view, the specific fields that warrant a select_related or prefetch_related can be described.","title":"Setting up eager loading"},{"location":"querying_data/#syntax-for-prefetch_related-and-select_related","text":"The format of syntax for select_related and prefetch_related is as follows select_related = { \"serializer_field_name\" : [ \"field_to_select\" ]} prefetch_related = { \"serializer_field_name\" : [ \"field_to_prefetch\" ]} If you are selecting or prefetching one field per serializer field name you can use select_related = { \"serializer_field_name\" : \"field_to_select\" } prefetch_related = { \"serializer_field_name\" : \"field_to_prefetch\" } Syntax Interpretation serializer_field_name stands for the name of the field to prefetch or select(as named on a serializer). fields_to_select stands for argument(s) to pass when calling select_related method. fields_to_prefetch stands for arguments(s) to pass when calling prefetch_related method. This can be a string or Prefetch object. If you want to select or prefetch nested field use dot(.) to separate parent and child fields on serializer_field_name eg parent.child .","title":"Syntax for prefetch_related and select_related"},{"location":"querying_data/#example-of-eagerloadingmixin-usage","text":"from rest_framework import viewsets from django_restql.mixins import EagerLoadingMixin from myapp.serializers import StudentSerializer from myapp.models import Student class StudentViewSet ( EagerLoadingMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () # The Interpretation of this is # Select `course` only if program field is included in a query select_related = { \"program\" : \"course\" } # The Interpretation of this is # Prefetch `course__books` only if program or program.books # fields are included in a query prefetch_related = { \"program.books\" : \"course__books\" }","title":"Example of EagerLoadingMixin usage"},{"location":"querying_data/#known-caveats","text":"When prefetching with a to_attr , ensure that there are no collisions. Django does not allow multiple prefetches with the same to_attr on the same queryset. When prefetching and calling select_related on a field, Django may error, since the ORM does allow prefetching a selectable field, but not both at the same time.","title":"Known Caveats"},{"location":"settings/","text":"Settings \u00b6 Configuration for Django RESTQL is all namespaced inside a single Django setting named RESTQL , below is a list of what you can configure under RESTQL setting. QUERY_PARAM_NAME \u00b6 The default value for this is query . If you don't want to use the name query as your parameter, you can change it with QUERY_PARAM_NAME on settings file e.g # settings.py file RESTQL = { 'QUERY_PARAM_NAME' : 'your_favourite_name' } Now you can use the name your_favourite_name as your query parameter. E.g GET /users/?your_favourite_name={id, username} MAX_ALIAS_LEN \u00b6 The default value for this is 50. When creating aliases this setting limit the number of characters allowed in aliases. This setting prevents DoS like attacks to API which might be caused by clients specifying a really really long alias which might increase network usage. If you want to change the default value, do as follows # settings.py file RESTQL = { 'MAX_ALIAS_LEN' : 100 # Put the value that you want here } AUTO_APPLY_EAGER_LOADING \u00b6 The default value for this is True . When using the EagerLoadingMixin , this setting controls if the mappings for select_related and prefetch_related are applied automatically when calling get_queryset . To turn it off, set the AUTO_APPLY_EAGER_LOADING setting or auto_apply_eager_loading attribute on the view to False . # settings.py file # This will turn off auto apply eager loading globally RESTQL = { 'AUTO_APPLY_EAGER_LOADING' : False } If auto apply eager loading is turned off, the method apply_eager_loading can still be used on your queryset if you wish to select or prefetch related fields according to your conditions, For example you can check if there was a query parameter passed in by using has_restql_query_param , if true then apply eager loading otherwise return a normal queryset. from rest_framework import viewsets from django_restql.mixins import EagerLoadingMixin from myapp.serializers import StudentSerializer from myapp.models import Student class StudentViewSet ( EagerLoadingMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () # Turn off auto apply eager loading per view # This overrides the `AUTO_APPLY_EAGER_LOADING` setting on this view auto_apply_eager_loading = False select_related = { \"program\" : \"course\" } prefetch_related = { \"program.books\" : \"course__books\" } def get_queryset ( self ): queryset = super () . get_queryset () if self . has_restql_query_param : queryset = self . apply_eager_loading ( queryset ) return queryset","title":"Settings"},{"location":"settings/#settings","text":"Configuration for Django RESTQL is all namespaced inside a single Django setting named RESTQL , below is a list of what you can configure under RESTQL setting.","title":"Settings"},{"location":"settings/#query_param_name","text":"The default value for this is query . If you don't want to use the name query as your parameter, you can change it with QUERY_PARAM_NAME on settings file e.g # settings.py file RESTQL = { 'QUERY_PARAM_NAME' : 'your_favourite_name' } Now you can use the name your_favourite_name as your query parameter. E.g GET /users/?your_favourite_name={id, username}","title":"QUERY_PARAM_NAME"},{"location":"settings/#max_alias_len","text":"The default value for this is 50. When creating aliases this setting limit the number of characters allowed in aliases. This setting prevents DoS like attacks to API which might be caused by clients specifying a really really long alias which might increase network usage. If you want to change the default value, do as follows # settings.py file RESTQL = { 'MAX_ALIAS_LEN' : 100 # Put the value that you want here }","title":"MAX_ALIAS_LEN"},{"location":"settings/#auto_apply_eager_loading","text":"The default value for this is True . When using the EagerLoadingMixin , this setting controls if the mappings for select_related and prefetch_related are applied automatically when calling get_queryset . To turn it off, set the AUTO_APPLY_EAGER_LOADING setting or auto_apply_eager_loading attribute on the view to False . # settings.py file # This will turn off auto apply eager loading globally RESTQL = { 'AUTO_APPLY_EAGER_LOADING' : False } If auto apply eager loading is turned off, the method apply_eager_loading can still be used on your queryset if you wish to select or prefetch related fields according to your conditions, For example you can check if there was a query parameter passed in by using has_restql_query_param , if true then apply eager loading otherwise return a normal queryset. from rest_framework import viewsets from django_restql.mixins import EagerLoadingMixin from myapp.serializers import StudentSerializer from myapp.models import Student class StudentViewSet ( EagerLoadingMixin , viewsets . ModelViewSet ): serializer_class = StudentSerializer queryset = Student . objects . all () # Turn off auto apply eager loading per view # This overrides the `AUTO_APPLY_EAGER_LOADING` setting on this view auto_apply_eager_loading = False select_related = { \"program\" : \"course\" } prefetch_related = { \"program.books\" : \"course__books\" } def get_queryset ( self ): queryset = super () . get_queryset () if self . has_restql_query_param : queryset = self . apply_eager_loading ( queryset ) return queryset","title":"AUTO_APPLY_EAGER_LOADING"}]}